clear;
% warning('off','all')
% addpath('../utils/desequilibradas')
addpath("../utils/comp_simetricas")
addpath("../utils/curto_circuito")
addpath("../utils/apoio/")
a = convert_phasor(1,120);
dlgtitle = 'Curto-circuito';

%% Gerador 1
'Gerador 1'
Vg1 = g_trifasico(13.8e3,100e6,13.8e3,100e6,0.1,0.15,0.15,'y','direta');

%% Gerador 2
'Gerador 2'
Vg2 = g_trifasico(13.8e3,100e6,13.8e3,100e6,0.07,0.2,0.2,'y','direta');

%% Trasnformador T1 - Núcleo Envolvente
'T1 - Base Original'
t1 = trans(13.8e3,138e3,100e6,0.1,0.1,0.1);
t1.lig_p = 'd';
t1.lig_s = 'yt';

%% Trasnformador T2 - Núcleo Envolvente
'T2 - Base Original'
t2 = trans(13.8e3,138e3,100e6,0.15,0.15,0.15);
t1.lig_p = 'yt';
t1.lig_s = 'y';

%% Linhas de transmissão
'Linhas de transmissão'
LT1 = LT_pu( ...
    'b', ...
    'c', ...
    0.32*70/t1.Zbs, ...
    0.28*70/t1.Zbs, ...
    0.28*70/t1.Zbs ...
);

LT2 = LT_pu( ...
    'b', ...
    'c', ...
    0.32*70/t1.Zbs, ...
    0.28*70/t1.Zbs, ...
    0.28*70/t1.Zbs ...
);


%% Associação do circuito de rede de sequência negativa e zero
'Associação das redes de sequência'
aux1 = get_paralelo_Zs(LT1.X2,LT2.X2) + Vg1.X2 + t1.X2;
fprintf('Impedância equivalente: %.4f/%.4f ou %ci (lembra de incluir o i nos calculos)\n',abs(aux1),angle(aux1)*180/pi,aux1);
aux2 = 1i*get_paralelo_Zs(aux1,(Vg2.X2 + t2.X2));
fprintf('Impedância equivalente: %.4f/%.4f ou %ci\n',abs(aux2),angle(aux2)*180/pi,aux2);
aux3 = 1i*(get_paralelo_Zs(LT1.X0,LT2.X0) + t1.X0);
fprintf('Impedância equivalente: %.4f/%.4f ou %ci\n',abs(aux3),angle(aux3)*180/pi,aux3);


%% Associação do circuito de sequência positiva com o simplificado anterior 

aux4 = get_paralelo_Zs(LT1.X1,LT2.X1) + Vg1.X1 + t1.X1;
fprintf('Impedância equivalente: %.4f/%.4f ou %ci (lembra de incluir o i nos calculos)\n',abs(aux4),angle(aux4)*180/pi,aux4);
aux5 = 1i*get_paralelo_Zs(aux4,(Vg2.X1 + t2.X1));
fprintf('Impedância equivalente: %.4f/%.4f ou %ci\n',abs(aux5),angle(aux5)*180/pi,aux5);

%% Cálculo da tensão de nó no ponto de falta
'Tensão de nó no ponto de falta'
Vcurto = convert_phasor(1,90)/(aux5);
Vcurto = Vcurto/(1/aux5 + 1/aux3 + 1/aux2);
fprintf('Tensão no ponto de falta: %.4f/%.4f ou %ci\n',abs(Vcurto),angle(Vcurto)*180/pi,Vcurto);

%% Correntes de falta em pu
'Correntes de falta em pu'
Ia0 = -Vcurto/aux3;
Ia1 = (convert_phasor(1,90)-Vcurto)/aux5;
Ia2 = -Vcurto/aux2;
get_phasor_m([Ia0; Ia1; Ia2]);

%% Correntes de falta em ampreres
'Correntes de falta em ampreres'
Iall = get_comp_fase([Ia0; Ia1; Ia2]);
Iall = Iall*t1.Ibases;
get_phasor_m(Iall);

%% Correntes na linha LT1
% 'positiva'
ILT1_seq_positiva = (1i*(Vg2.X1 + t2.X1)*Ia1)/(1i*(Vg2.X1 + t2.X1) + 1i*aux4);
ILTa1 = ILT1_seq_positiva/2; % impedancias iguais da linha
fprintf('Corrente no local de falta em LT1: %.4f/%.4f ou %ci\n',abs(ILTa1),angle(ILTa1)*180/pi,ILTa1);

% 'negativa'
ILT1_seq_negativa = (1i*(Vg2.X2 + t2.X2)*Ia2)/(1i*(Vg2.X2 + t2.X2) + 1i*(get_paralelo_Zs(LT1.X2,LT2.X2) + Vg1.X2 + t1.X2));
ILTa2 = ILT1_seq_negativa/2; % impedancias iguais da linha
fprintf('Corrente no local de falta em LT1: %.4f/%.4f ou %ci\n',abs(ILTa2),angle(ILTa2)*180/pi,ILTa2);

% 'zero'
% ILT1_seq_zero = (1i*(t2.X0)*Ia2)/(1i*(t2.X0) + 1i*aux3);
ILTa0 = Ia0/2; % impedancias iguais da linha
fprintf('Corrente no local de falta em LT1: %.4f/%.4f ou %ci\n',abs(ILTa0),angle(ILTa0)*180/pi,ILTa0);

%% Correntes Reais em LT1
'Correntes Reais em LT1 em amperes'
IallLT1 = get_comp_fase([ILTa0; ILTa1; ILTa2]);
IallLT1 = IallLT1*t1.Ibases;
get_phasor_m(IallLT1);


%% Correntes no Gerador G1
% 'positiva'
IG1a1 = ILT1_seq_positiva;
fprintf('Corrente de falta em G1: %.4f/%.4f ou %ci\n',abs(IG1a1),angle(IG1a1)*180/pi,IG1a1);

% 'negativa'
IG1a2 = ILT1_seq_negativa;
fprintf('Corrente de falta em G1: %.4f/%.4f ou %ci\n',abs(IG1a2),angle(IG1a2)*180/pi,IG1a2);

% 'zero'
IG1a0 = 0; % gerador em aberto
fprintf('Corrente de falta em G1: %.4f/%.4f ou %ci\n',abs(IG1a0),angle(IG1a0)*180/pi,IG1a0);

%% Correntes Reais em G1
'Correntes Reais em G1 em amperes'
% Como estamos passando do lado y para o delta em um transformador, para
% sequencia positiva atrasa a corrente em -30. Por outro lado, para a
% sequência negativa, adianta a corrente em 30.
IallG1 = get_comp_fase([IG1a0; IG1a1*convert_phasor(1,-30); IG1a2*convert_phasor(1,30)]);
% get_phasor_m(IG1a1);
IallG1 = IallG1*t1.Ibasep;
get_phasor_m(IallG1);

%% Corrente que sobre em T1 pelo aterramento
% A corrente que sobre em T1 pelo aterramento é a corrente da rede de
% sequência zero multiplicada por 3. Essa também é igual a corrente das fases B e
% C somadas, isto é, onde ocorreu o curto-circuito bifásico terra.
IT1 = 3*abs(Ia0)*t1.Ibases;
fprintf('Corrente que sobe pelo aterramento de T1: %.4f A\n',abs(IG1a0),angle(IG1a0)*180/pi,IG1a0);